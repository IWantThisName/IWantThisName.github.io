<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[博客应用next主题]]></title>
      <url>%2F2016%2F03%2F20%2F%E5%8D%9A%E5%AE%A2%E5%BA%94%E7%94%A8next%20%E4%B8%BB%E9%A2%98%2F</url>
      <content type="text"><![CDATA[下载next主题并应用到hexo博客上 下载next主题点击这里按照下图进行下载 下载完成后进行解压将解压后的文件夹名字重命名为next,放到blog目录下的theme文件夹下 修改blog目录下的_config.yml站点配置文件 在blog目录下按住shift+右键,打开命令行窗口 在命令行里键入以下命令 D:\nodejs\blog&gt; hexo g D:\nodejs\blog&gt; hexo d 然后重新键入你的博客页面,就可以看到页面已经更换了 next主题的一些优化以下的配置文件修改都是针对next主题下的_config.yml文件,修改后重新hexo g,hexo d即可以看到修改效果 主题风格的选择默认有三种风格可以选择,我选择的是Mist 菜单页面配置我选择显示了主页,关于页,分类页,标签页和归档页,如下所示 头像设置就是设置这里的头像将要设置的图像重名为avatar.gif覆盖在themes/next/source/images下avatar.gif文件就可以设置自己想要的头像了需要注意的是,只能覆盖avatar.gif,不然会报错= =在themes/next/_config.yml文件中有下面这个配置但是设置了自己定义的图片名还是会报错 设置文章的代码主题有5中代码风格可以选择,我选择的是normal 引入第三方服务以下的配置文件修改都是针对next主题下的_config.yml文件,修改后重新hexo g,hexo d即可以看到修改效果 加入评论功能点击这里注册多说评论服务登录多说后,点击我要安装然后填写相应信息,主要的就是下方画红圈处记住你填写的多说域名,然后去修改配置文件修改后的效果为,每篇博客后都有 加入分享功能分享功能也是使用的多说按照下面修改配置文件,将duoshuo_share设置为true修改后的效果为,每篇博客后都有 加入站点搜索功能本站点使用的是Local Search。加入站点内容搜索功能步骤如下：安装hexo-generator-searchdb $ npm install hexo-generator-searchdb --save 注意：安装时应在站点根目录下，即blog目录下不过我安装失败了 = =如果安装成功,就修改站点的配置文件(blog目录下的,不是next主题下的),添加如下字段然后就可以生效了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[activeMq数据持久化]]></title>
      <url>%2F2016%2F03%2F14%2FactiveMq%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%2F</url>
      <content type="text"><![CDATA[ActiveMQ数据持久化总共有三种方式, 默认文件存储 在kahadb中 还可以保存在mysql和oracle中 对于点对点的方式, 数据存储会自动进行持久化.对于发布/订阅方式,需要通过代码进行设置. 并且保证已经连通过了一次, 否则消费者无法接收到信息. 发布/订阅发布者设置持久化模式 发布/订阅消费者获取信息 设置消费者id,并且保证每一个消费者id唯一. 通过mysql保存数据信息把mysql的驱动jar包放到amq的lib目录下到amq/conf中, 修改activemq.xml文件注释掉 &lt;persistenceAdapter&gt; &lt;kahaDB directory=&quot;${activemq.base}/data/kahadb&quot;/&gt; &lt;/persistenceAdapter&gt; 改为 &lt;persistenceAdapter&gt; &lt;jdbcPersistenceAdapter dataDirectory=&quot;${activemq.base}/data&quot; dataSource=&quot;#derby-ds&quot;/&gt; &lt;/persistenceAdapter&gt; 同时在后面加上 &lt;bean id=&quot;derby-ds&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost/activemq?relaxAutoCommit=true&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;activemq&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;activemq&quot;/&gt; &lt;property name=&quot;maxActive&quot; value=&quot;200&quot;/&gt; &lt;property name=&quot;poolPreparedStatements&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; 在mysql中创建activemq数据库 启动mysql这样就会产生三张与activemq相关的表]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[activeMq服务器搭建]]></title>
      <url>%2F2016%2F03%2F12%2FactiveMQ%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[activeMq服务器搭建 下载ActiveMQ 配置jdk环境 解压activeMQ安装包 运行使用bin目录下的activemq命令启动：[root@localhost bin]# ./activemq start关闭：[root@localhost bin]# ./activemq stop查看状态：[root@localhost bin]# ./activemq status 访问activeMQ默认帐号密码 admin admin]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[nginx负载均衡服务器搭建]]></title>
      <url>%2F2016%2F03%2F10%2Fnginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[nginx安装 官网下载nginx 安装相关依赖 yum install gcc-c++ yum install -y pcre pcre-devel yum install -y zlib zlib-devel yum install -y openssl openssl-devel 解压缩nginx的安装包 使用configure命令创建一makeFile文件。 ./configure \ --prefix=/usr/local/nginx \ --pid-path=/var/run/nginx/nginx.pid \ --lock-path=/var/lock/nginx.lock \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --with-http_gzip_static_module \ --http-client-body-temp-path=/var/temp/nginx/client \ --http-proxy-temp-path=/var/temp/nginx/proxy \ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \ --http-scgi-temp-path=/var/temp/nginx/scgi 创建nginx运行所需目录 mkdir -p /var/temp/nginx/ make make install 启动nginx进入sbin目录 [root@localhost sbin]# ./nginx 关闭nginx： [root@localhost sbin]# ./nginx -s stop 推荐使用： [root@localhost sbin]# ./nginx -s quit 重启nginx：1、先关闭后启动。2、刷新配置文件： [root@localhost sbin]# ./nginx -s reload 配置虚拟主机通过端口区分Nginx的配置文件：/usr/local/nginx/conf/nginx.conf #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { #一个server节点就是一个虚拟主机 listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; #html是nginx安装目录下的html目录 index index.html index.htm; } } } 可以配置多个server，配置了多个虚拟主机。添加虚拟主机： #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } } server { listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html-81; index index.html index.htm; } } } 重新加载配置文件 [root@localhost nginx]# sbin/nginx -s reload 通过域名区分 #user nobody; worker_processes 1; #error_log logs/error.log; #error_log logs/error.log notice; #error_log logs/error.log info; #pid logs/nginx.pid; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; #log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; # &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; # &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; index index.html index.htm; } } server { listen 81; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / { root html-81; index index.html index.htm; } } server { listen 80; server_name www.taobao.com; #charset koi8-r; #access_log logs/host.access.log main; location / { root html-taobao; index index.html index.htm; } } server { listen 80; server_name www.baidu.com; #charset koi8-r; #access_log logs/host.access.log main; location / { root html-baidu; index index.html index.htm; } } } 配置反向代理服务器第一步：安装两个tomcat，分别运行在8080和8081端口。第二步：启动两个tomcat。第三步：反向代理服务器的配置 upstream tomcat1 { server 192.168.25.148:8080; } server { listen 80; server_name www.sina.com.cn; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://tomcat1; index index.html index.htm; } } upstream tomcat2 { server 192.168.25.148:8081; } server { listen 80; server_name www.sohu.com; #charset koi8-r; #access_log logs/host.access.log main; location / { proxy_pass http://tomcat2; index index.html index.htm; } } 第四步：nginx重新加载配置文件 第五步：配置域名在hosts文件中添加域名和ip的映射关系192.168.25.148 www.sina.com.cn192.168.25.148 www.sohu.com 配置负载均衡在hosts文件中添加多个相同域名的服务器 upstream tomcat2 { server 192.168.25.148:8081; server 192.168.25.148:8082; } 为多个服务器分配权重 upstream tomcat2 { server 192.168.25.148:8081 weifht=3;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis集群版搭建]]></title>
      <url>%2F2016%2F03%2F08%2Fredis%E9%9B%86%E7%BE%A4%E7%89%88%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[集群搭建环境 使用ruby脚本搭建集群。需要ruby的运行环境。安装ruby yum install ruby yum install rubygems 安装ruby脚本运行使用的包。 [root@localhost ~]# gem install redis-3.0.0.gem Successfully installed redis-3.0.0 1 gem installed Installing ri documentation for redis-3.0.0... Installing RDoc documentation for redis-3.0.0... [root@localhost ~]# [root@localhost ~]# cd redis-3.0.0/src [root@localhost src]# ll *.rb -rwxrwxr-x. 1 root root 48141 Apr 1 2015 redis-trib.rb 搭建步骤需要6台redis服务器。搭建伪分布式。需要6个redis实例。需要运行在不同的端口7001-7006 第一步：创建6个redis实例，每个实例运行在不同的端口。需要修改redis.conf配置文件。配置文件中还需要把cluster-enabled yes前的注释去掉。 第二步：启动每个redis实例。第三步：使用ruby脚本搭建集群。 ./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005 192.168.25.153:7006 创建关闭集群的脚本： [root@localhost redis-cluster]# vim shutdow-all.sh redis01/redis-cli -p 7001 shutdown redis01/redis-cli -p 7002 shutdown redis01/redis-cli -p 7003 shutdown redis01/redis-cli -p 7004 shutdown redis01/redis-cli -p 7005 shutdown redis01/redis-cli -p 7006 shutdown [root@localhost redis-cluster]# chmod u+x shutdow-all.sh [root@localhost redis-cluster]# ./redis-trib.rb create --replicas 1 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 192.168.25.153:7004 192.168.25.153:7005 192.168.25.153:7006 &gt;&gt;&gt; Creating cluster Connecting to node 192.168.25.153:7001: OK Connecting to node 192.168.25.153:7002: OK Connecting to node 192.168.25.153:7003: OK Connecting to node 192.168.25.153:7004: OK Connecting to node 192.168.25.153:7005: OK Connecting to node 192.168.25.153:7006: OK &gt;&gt;&gt; Performing hash slots allocation on 6 nodes... Using 3 masters: 192.168.25.153:7001 192.168.25.153:7002 192.168.25.153:7003 Adding replica 192.168.25.153:7004 to 192.168.25.153:7001 Adding replica 192.168.25.153:7005 to 192.168.25.153:7002 Adding replica 192.168.25.153:7006 to 192.168.25.153:7003 M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001 slots:0-5460 (5461 slots) master M: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002 slots:5461-10922 (5462 slots) master M: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003 slots:10923-16383 (5461 slots) master S: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004 replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 S: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005 replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01 S: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006 replicates 2935007902d83f20b1253d7f43dae32aab9744e6 Can I set the above configuration? (type &apos;yes&apos; to accept): yes &gt;&gt;&gt; Nodes configuration updated &gt;&gt;&gt; Assign a different config epoch to each node &gt;&gt;&gt; Sending CLUSTER MEET messages to join the cluster Waiting for the cluster to join..... &gt;&gt;&gt; Performing Cluster Check (using node 192.168.25.153:7001) M: 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 192.168.25.153:7001 slots:0-5460 (5461 slots) master M: 8cd93a9a943b4ef851af6a03edd699a6061ace01 192.168.25.153:7002 slots:5461-10922 (5462 slots) master M: 2935007902d83f20b1253d7f43dae32aab9744e6 192.168.25.153:7003 slots:10923-16383 (5461 slots) master M: 74f9d9706f848471583929fc8bbde3c8e99e211b 192.168.25.153:7004 slots: (0 slots) master replicates 2e48ae301e9c32b04a7d4d92e15e98e78de8c1f3 M: 42cc9e25ebb19dda92591364c1df4b3a518b795b 192.168.25.153:7005 slots: (0 slots) master replicates 8cd93a9a943b4ef851af6a03edd699a6061ace01 M: 8b1b11d509d29659c2831e7a9f6469c060dfcd39 192.168.25.153:7006 slots: (0 slots) master replicates 2935007902d83f20b1253d7f43dae32aab9744e6 [OK] All nodes agree about slots configuration. &gt;&gt;&gt; Check for open slots... &gt;&gt;&gt; Check slots coverage... [OK] All 16384 slots covered. [root@localhost redis-cluster]# 集群的使用方法Redis-cli连接集群。 [root@localhost redis-cluster]# redis01/redis-cli -p 7002 -c -c：代表连接的是redis集群]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redis单机版搭建]]></title>
      <url>%2F2016%2F03%2F06%2Fredis%E5%8D%95%E6%9C%BA%E7%89%88%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[redis单机版搭建安装步骤：第一步：redis的源码包上传到linux系统。第二步：解压缩redis。第三步：编译。make第四步：安装。make install PREFIX=/usr/local/redis 1.1.连接redis1.1.1.redis的启动：前端启动： [root@localhost bin]# ./redis-server 后台启动：把/root/redis-3.0.0/redis.conf复制到/usr/local/redis/bin目录下 [root@localhost redis-3.0.0]# cp redis.conf /usr/local/redis/bin/ 修改配置文件： [root@localhost bin]# ./redis-server redis.conf查看redis进程： [root@localhost bin]# ps aux|grep redis root 5190 0.1 0.3 33936 1712 ? Ssl 18:23 0:00 ./redis-server *:6379 root 5196 0.0 0.1 4356 728 pts/0 S+ 18:24 0:00 grep redis [root@localhost bin]# 1.1.2.Redis-cli客户端使用 [root@localhost bin]# ./redis-cli 默认连接localhost运行在6379端口的redis服务。 [root@localhost bin]# ./redis-cli -h 192.168.25.153 -p 6379 -h：连接的服务器的地址-p：服务的端口号]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[solr单机版搭建]]></title>
      <url>%2F2016%2F03%2F03%2Fsolr%E5%8D%95%E6%9C%BA%E7%89%88%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[solr安装第一步：把solr 的压缩包上传到Linux系统 第二步：解压solr。 第三步：安装Tomcat，解压缩即可. 第四步：把solr部署到Tomcat下。 第五步：解压缩war包。启动Tomcat解压。 第六步：把/root/solr-4.10.3/example/lib/ext目录下的所有的jar包，添加到solr工程中。 [root@localhost ext]# pwd /root/solr-4.10.3/example/lib/ext [root@localhost ext]# cp * /usr/local/solr/tomcat/webapps/solr/WEB-INF/lib/ 第七步：创建一个solrhome。/example/solr目录就是一个solrhome。复制此目录到/usr/local/solr/solrhome [root@localhost example]# pwd /root/solr-4.10.3/example [root@localhost example]# cp -r solr /usr/local/solr/solrhome [root@localhost example]# 第八步：关联solr及solrhome。需要修改solr工程的web.xml文件。 第九步：启动Tomcat访问http://192.168.25.154:8080/solr/和windows下的配置完全一样。 配置ik分词器第一步：把中文分析器添加到工程中。1、把IKAnalyzer2012FF_u1.jar添加到solr工程的lib目录下2、创建classes目录,把扩展词典、配置文件放到solr工程的WEB-INF/classes目录下。3、进入solrhome/collection1/conf中,编辑schma.xml 第二步：配置一个FieldType，制定使用IKAnalyzer修改Solr的schema.xml文件，添加FieldType： &lt;fieldType name=&quot;text_ik&quot; class=&quot;solr.TextField&quot;&gt; &lt;analyzer class=&quot;org.wltea.analyzer.lucene.IKAnalyzer&quot;/&gt; &lt;/fieldType&gt; 第三步：配置业务域，type制定使用自定义的FieldType。设置业务系统Field &lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&quot;item_sell_point&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&quot;item_price&quot; type=&quot;long&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt; &lt;field name=&quot;item_image&quot; type=&quot;string&quot; indexed=&quot;false&quot; stored=&quot;true&quot; /&gt; &lt;field name=&quot;item_category_name&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt; &lt;field name=&quot;item_desc&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; /&gt; &lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt; &lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt; &lt;copyField source=&quot;item_sell_point&quot; dest=&quot;item_keywords&quot;/&gt; &lt;copyField source=&quot;item_category_name&quot; dest=&quot;item_keywords&quot;/&gt; &lt;copyField source=&quot;item_desc&quot; dest=&quot;item_keywords&quot;/&gt; 第四步：重启tomcat 业务域属于开发者自定义范围内]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[solr集群版搭建]]></title>
      <url>%2F2016%2F03%2F03%2Fsolr%E9%9B%86%E7%BE%A4%E7%89%88%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Solr集群的搭建第一步：创建四个tomcat实例。每个tomcat运行在不同的端口。8180、8280、8380、8480 第二步：部署solr的war包。把单机版的solr工程复制到集群中的tomcat中。 第三步：为每个solr实例创建一个对应的solrhome。使用单机版的solrhome复制四份。 第四步：需要修改solr的web.xml文件。把solrhome关联起来。 第五步：配置solrCloud相关的配置。每个solrhome下都有一个solr.xml，把其中的ip及端口号配置好。 第六步：让zookeeper统一管理配置文件。需要把solrhome/collection1/conf目录上传到zookeeper。上传任意solrhome中的配置文件即可。 使用工具上传配置文件：/root/solr-4.10.3/example/scripts/cloud-scripts/zkcli.sh ./zkcli.sh -zkhost 192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183 -cmd upconfig -confdir /usr/local/solr-cloud/solrhome01/collection1/conf -confname myconf 查看zookeeper上的配置文件：使用zookeeper目录下的bin/zkCli.sh命令查看zookeeper上的配置文件： [root@localhost bin]# ./zkCli.sh [zk: localhost:2181(CONNECTED) 0] ls / [configs, zookeeper] [zk: localhost:2181(CONNECTED) 1] ls /configs [myconf] [zk: localhost:2181(CONNECTED) 2] ls /configs/myconf [admin-extra.menu-top.html, currency.xml, protwords.txt, mapping-FoldToASCII.txt, _schema_analysis_synonyms_english.json, _rest_managed.json, solrconfig.xml, _schema_analysis_stopwords_english.json, stopwords.txt, lang, spellings.txt, mapping-ISOLatin1Accent.txt, admin-extra.html, xslt, synonyms.txt, scripts.conf, update-script.js, velocity, elevate.xml, admin-extra.menu-bottom.html, clustering, schema.xml] [zk: localhost:2181(CONNECTED) 3] 退出： [zk: localhost:2181(CONNECTED) 3] quit 第七步：修改tomcat/bin目录下的catalina.sh 文件，关联solr和zookeeper。把此配置添加到配置文件中： JAVA_OPTS=&quot;-DzkHost=192.168.25.154:2181,192.168.25.154:2182,192.168.25.154:2183&quot; 第八步：启动每个tomcat实例。要包装zookeeper集群是启动状态。 第九步：访问集群 第十步：创建新的Collection进行分片处理。http://192.168.25.154:8180/solr/admin/collectionsaction=CREATE&amp;name=collection2&amp;numShards=2&amp;replicationFactor=2 第十一步：删除不用的Collection。http://192.168.25.154:8180/solr/admin/collections?action=DELETE&amp;name=collection1]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[zookeeper集群版搭建]]></title>
      <url>%2F2016%2F03%2F02%2Fzookeeper%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA%2F</url>
      <content type="text"><![CDATA[Zookeeper集群搭建第一步：需要安装jdk环境。 第二步：把zookeeper的压缩包上传到服务器。 第三步：解压缩。 第四步：把zookeeper复制三份。 [root@localhost ~]# mkdir /usr/local/solr-cloud [root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper01 [root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper02 [root@localhost ~]# cp -r zookeeper-3.4.6 /usr/local/solr-cloud/zookeeper03 第五步：在每个zookeeper目录下创建一个data目录。 第六步：在data目录下创建一个myid文件，文件名就叫做“myid”。内容就是每个实例的id。例如1、2、3 [root@localhost data]# echo 1 &gt;&gt; myid [root@localhost data]# ll total 4 -rw-r--r--. 1 root root 2 Apr 7 18:23 myid [root@localhost data]# cat myid 1 第七步：修改配置文件。把conf目录下的zoo_sample.cfg文件改名为zoo.cfg server.1=192.168.25.154:2881:3881 server.2=192.168.25.154:2882:3882 server.3=192.168.25.154:2883:3883 第八步：启动每个zookeeper实例。启动bin/zkServer.sh start 查看zookeeper的状态：bin/zkServer.sh status]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[mongodb学习]]></title>
      <url>%2F2016%2F03%2F01%2Fmongodb%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[Mongodb目录建立 安装mongodb进入mongodb/bin目录Shift加右键进入命令行窗口mongod –dbpath=F:\develop\mongodb\dbrepository–logpath=F:\develop\mongodb\log.txt –install执行以上命令,mongodb数据库就安装成功了然后执行 net start MongoDB即开启mongodb数据库服务 卸载mongodb服务net stop MongoDb关闭mongodb数据库服务后执行以下命令mongod –dbpath=F:\develop\mongodb\dbrepository–logpath=F:\develop\mongodb\log.txt –remove使用客户端连接数据库直接在命令行输入 mongo.exe就可 Mongo常用操作 查询当前数据库名称db.getName() 创建数据库Use 数据库名称 查看数据库状态db.stats() 简单运算 查看数据库相关帮助信息db.help() 写入数据 普通数据的添加Json格式 Bson格式，类json格式db.goods.insert({name:”huawei”,price:1000,weight:135,number:35}) 多维数据的添加db.goods.insert({name:”huawei”,price:1000,weight:135,number:35,area:{province:anhui,city:hefei}}) 数组信息的添加db.goods.insert({name:”huawei”,price:1000,weight:135,number:35,area:{province:anhui,city:hefei},color:[“blank”,”white”,”red”]}) 数据查询 笼统方式查询1.1 db.数据表.find() //查询数据表的全部数据1.2 db.数据表.findOne() //查询数据表中的第一条数据 条件限制查询2.1 db.数据表.find(条件) //条件也用键值对db.goods.find({name:”huawei”}) //相当于 select * from goods where name = “huawei”2.2 db.数据表.findOne(条件) //返回满足结果里的第一条消息db.goods.findOne({name:”huawei”})值得一提的是,mongodb中的_id的值是mongodb自身算法算出来的,全球唯一,也可以显示去指定_id的值,db.goods.insert({_id:2,….}),但是不建议这么做 范围条件查询关键字: $lt,$gt,$lte,$gte相当于mysql中的 &lt; &gt; &lt;= &gt;=db.goods.find({price:{‘$gte’:1000}}) //查询价格大于等于1000的商品注意:$gte必须用引号括起来,单双引号都行 设置多个查询条件db.数据表.find({条件,条件,条件}) 相当于sql的anddb.goods.find({price:{“$gte”:1000},weight:{”$lte”:135}})//查询价格大于等于1000并且重量小于等于135的商品db.goods.find({price:{“$gte”:1000},weight:135})查询价格大于等于1000并且重量为135的商品 多维字段的查询db.数据表.find({“key.name”:值})多维字段查询和普通字段写法相似,都是写条件,不过区别是条件的键是key.name多维形式的 数组条件查询db.goods.find({color:”white”}) //只要color数组中有white这个值就行db.goods.find({color:{“$all”:[“black”,”white”]}})$all代表全部满足 所以当color数组中同时有black和white就满足这个查询条件 限制查询条件我们刚才的查询，是显示的所有的信息字段，但是呢，实际情况操作中，我们不一定全部都用到，那么可以就需要做一个字段输出查询的一个限制。如果全部取出来的话，对于内存和带宽都一定影响，我们按需去操作就可以了。db.表.find({条件},{字段：1/0,字段：1/0}1: 查询此字段0: 排除此字段规则：就是要输出就全部输出，要不输出就全部不输出。_id 除外，可以随意设置0,1,并且_id默认是输出的db.goods.find({price:{“$gte”:1000},{name:1,_id:0}}) //这个可以正常查询db.goods.find({price:{“$gte”:1000},{name:0,price:1}}) //这个会报错,因为要么就全写需要输出的,要么就全写不需要输出的要是0都是0，要是1都是1 $or查询，多个条件，满足其一即可db.goods.find({“$or”:[{price:{“$gt”:1000}},{weight:135}]}) 修改数据db.表.update({条件},{‘$set’:{字段：值,字段:值……}})db.表.update({条件},{字段：值,字段:值……})有$set的修改：只修改设置的字段，其他字段不变化没有$set的修改：只修改设置的字段，没有修改的字段就删除了(除了_id字段) 数据表原来没有的字段直接添加为新字段 删除数据1)删除记录 db.表.remove(条件)2)删除字段 db.表.update({条件},{‘$unset’:{字段:1/字段:0}}) 0和1没有区别]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python学习2]]></title>
      <url>%2F2016%2F02%2F25%2Fpython%E5%AD%A6%E4%B9%A02%2F</url>
      <content type="text"><![CDATA[python中的io流 打开文件在python,使用open函数,可以打开一个已经存在的文件,或者创建一个新文件open(文件名,访问模式)用法:f = open(‘test.txt’,’w’)说明:以可写方式打开test.txt文件,f用于代表文件对象访问模式主要有以下几种:r 以只读方式打开文件.文件的指针将会放在文件的开头.这是默认模式w 打开一个文件只用于写入.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件a 打开一个文件用于追加.如果该文件已存在,文件指针将会放在文件的结尾.也就是说,新的内容将会写入到已有内容之后.如果该文件不存在,创建新文件进行写入.rb 以二进制格式打开一个文件用于只读.文件指针将会放在文件的开头.这是默认模式wb 以二进制格式打开一个文件只用于写入.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件ab 以二进制格式打开一个文件用于追加.如果该文件已存在,文件指针将会放在文件的末尾.也就是说,新的内容将会被写入到已有内容之后,如果该文件不存在,创建新文件进行写入r+ 打开一个文件用于读写.文件指针将会放在文件的开头.w+ 打开一个文件用于读写.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件a+ 打开一个文件用于读写,如果该文件存在,文件指针将会放在文件的结尾.文件打开时会是追加模式.如果该文件不存在,创建新文件用于读写.rb+ 以二进制格式打开一个文件用于读写.文件指针将会放在文件的开头.wb+ 以二进制格式打开一个文件用于读写.如果该文件已存在则将其覆盖.如果该文件不存在,创建新文件..ab+ 以二进制格式打开一个文件用于追加.如果该文件已存在,文件指针将会放在文件的结尾.如果该文件不存在,创建新文件用于读写 关闭文件close()用法 f.close() 文件的读写之写数据write() 可以向文件写入数据用法:f = open(‘test.txt’,’w’)f.write(‘hello world,i am python’)f.close()注意:如果文件不存在那么创建,如果存在那么就先清空,然后写入数据 文件的读写之读数据read(num) 可以从文件中读取数据,num表示要从文件中读取的数据的长度(单位是字节),如果没有传入num,那么就表示读取文件中所有的数据用法:f = open(‘text.txt’,’r’)content = f.read(5) #读取五个字节数据print(content)content = f.read() #不指定num,代表读取全部数据print(content)f.close()注意:r如果open是打开一个文件用于读数据,那么可以不用写打开的模式,即只写open(‘test.txt’) 如果使用read(num)方法多次,那么后面读取的数据是从上次读完后的位置开始的 读数据之readlines就像read没有参数时一样,readlines可以按照行的方式把整个文件中的内容进行一次性读取,并且返回的是一个列表,其中每一行的数据为一个元素用法:f = open(‘text.txt’,’r’)content = f.readlines() #content接收的是一个列表,列表中的每一个元素都是文件中的一行内容for i in content: print(i) 读数据之readline相较于readlines()是一次读取整个文件,将文件中的每一行都当成列表中的元素,然后返回列 表,,readline()是每调用一次,就读取一行数据,返回的是一个字符串,当多次使用时,后面读取的数据是从上次读完后的位置开始的用法:f = open(‘text.txt’,’r’)content = f.readline() #第一次调用,读取文件的第一行数据print(content)content = f.readline() #第二次调用,接着上次读完后的位置读取,读取文件的第二行数据print(content) 文件操作 获取当前读写的位置在读写文件的过程中,如果想知道当前的位置,可以使用tell()来获取 定位到某个位置如果在读写文件的过程中,需要从另外一个位置进行操作的话,可以使用seek(offset,from)offset:偏移量from: 方向 0:表示文件开头 1:表示当前位置 2:表示文件末尾从文件开头,偏移5个字节f = open(“test.txt”,”r”)f.seek(5,0)离文件末尾,3个字节f = open(“test.txt”,”r”)f.seek(-3,2) 文件重命名,删除有些时候,需要对文件进行重命名,删除等一些操作,python的os模块中都有这些功能 文件重命名os模块中的rename()可以完成对文件的重命名操作rename(需要修改的文件名,新的文件名)import os #导入os模块os.rename(“test.txt”,”demo.txt”) #将test.txt名字改为demo.txt 删除文件os模块中的remove()可以完成对文件的删除操作remove(待删除的文件名)import osos.remove(“test.txt”) #将test.txt文件删除 文件夹的相关操作os模块也可以用来操作文件夹1.创建文件夹import osos.mkdir(“张三”) #创建一个名称为张三的文件夹 获取当前目录import osos.getcwd() #获取当前的工作目录 改变默认目录import osos.chdir(“../“) #将当前工作目录改为上一级 获取目录列表import osos.listdir(“./“) #获取当前目录下的文件列表 删除文件夹import osos.rmdir(“张三”) #将名字为张三的文件夹删除 python中的类python中的类的概念和其他面向对象语言一样python中类的定义class 类名: 方法列表 创建对象格式对象名 = 类名() 对象的使用使用对象.一个不存在的属性,相当于给该对象添加属性 python中的init方法相当于java中的构造器,可以在创建对象时对对象进行数据的初始化操作 注意: init方法,在创建一个对象时默认被调用,不需要手动调用 init(self)中,默认有1个参数名字为self,如果在创建对象时传递了2个实参,那么 init(self)中除了 self作为第一个形参外还需要2个形参,例如init (self,x,y) init_(self)中的self参数,不需要开发者传递,pythono解释器会自己进行传递 魔法方法id()可以获取对象的地址值 #coding #面向对象的一些操作 class Car: def __init__(self,color,price): self.color = color self.color = price def run(): print(&quot;车在奔跑&quot;) def mingdi(): print(&quot;车在鸣笛...嘟嘟..&quot;) audi = Car(&quot;红色&quot;,&quot;50万&quot;) &gt;&gt;&gt; print(audi) &lt;__main__.Car object at 0x02F4B870&gt; (直接打印对象显示的是一串对象的信息) &gt;&gt;&gt; print(id(audi)) 49592432 (id方法获取对象的地址) str()方法相当于java中对象的toString()方法,在类中定义了这个方法,将会在打印对象时打印str方法中定义的内容在Car类加上str方法 def __str__(self): msg = &quot;车颜色是&quot;+self.color+&quot;,车价格是&quot;+self.price return msg 这时再创建对象,再打印对象,显示的就是str中定义的内容 audi = Car(&quot;红色&quot;,&quot;50万&quot;) &gt;&gt;&gt; print(audi) 车颜色是红色,车价格是50万 总结:在python中方法名如果是xxxx()的,那么就有特殊的功能,因此叫做”魔法”方法当使用能够print输出对象的时候,只要自己定义了str(self)方法,那么就会打印从在这个方法中return的数据 python的self相当于java中的this关键字 123456比如 self.color 可以被直接访问,self.__color 不可以被直接访问,方法同理 ```__del__() 方法 类似java对象中的finalize方法,当对象被清理时调用该方法 del 对象名 即是清理对象 不过python对于对象的处理和java不同当有1个变量保存了对象的引用时,此对象的引用计数就会加1当使用del删除变量指向的对象时,如果对象的引用技术不为1,比如3,那么此时只会让这个引用计数减1,即变为2,当再次调用del时,变为1,如果再调用1次del,此时会真的把对象进行删除 python中的继承python中的继承概念和java中的相同用法:子类在继承的时候,在定义类时,小括号()中为父类的名字 父类的属性,方法,会被继承给子类 注意点:私有的属性,不能通过对象直接访问,但是可以通过方法访问 私有的方法,不能通过对象直接访问 私有的属性,方法,不会被子类继承,也不能被访问 一般情况行啊,私有的属性,方法都是不对外公布的,往往用来做内部的事情,起到安全的作用 python是支持多继承的用法就是在定义类时,在类后面的括号里写上继承的类名,多个之间用逗号隔开class A() class B() class C(A,B)类C同时继承了类A和类B 类A和类B中的非私有方法都会被类C继承 当支持多继承时,就会出现一个现象,当继承的两个类中有相同的方法,这个类调用这个方法会产生什么效果可以通过类名.mro 查看对象搜索方法时的先后顺序(试了一下,貌似跟括号里写继承类的继承顺序有关) python中也有方法重写的概念,在子类中写跟父类同名的方法,可以覆盖掉父类的方法实现 python调用父类的方法是通过super()函数,super().方法名调用,跟java的不同就是多两个括号 python中的类属性和实例属性类属性就是直接在方法外定义的属性,实例属性,通过self.变量名定义的就是实例属性类属性和java中的静态变量相仿,实例属性和java中的实例变量相仿 修改类属性的话,必须通过类名.来调用修改,用对象名.调用的话,会在对象中新增一个同名的实例属性,之后用该对象引用时,都只会显示该实例属性的值,屏蔽掉了类属性,除非删除这个实例属性 del 对象名.属性 python中的类方法和静态方法类方法的定义,在方法名上加上注解@classmethod 则这个方法就变成了类方法,且该方法的参数得改成cls,代表该类的引用,而不是self对象的引用 静态方法的定义,在方法名上加上注解@staticmethod 则这个方法就变成了静态方法,静态方法不需要传任何参数,所以在静态方法中操作属性,只能通过类名.调用类属性 python中的异常python中报错 可以通过 try: xxx except 错误名: 解决方式 结构来抓取异常,进行相应操作 这里介绍python中的一个关键字 pass 使用pass代表实现了相应的实现,但是啥也没做 在接收错误名的后面,可以加上一个参数,errorMsg,用于接收具体的错误信息 try: xxxx except error,errorMsg: print(errorMsg) 捕获多个异常 ,可以使用元组的方式 try: xxxx except (error1,error2),errorMsg: print(errorMsg) python中 也可以在后面加上finally分支,用来进行一些必须要进行的操作,比如关闭链接 try: xxxx except error1,errorMsg: print(errorMsg) finally: 释放资源的操作 在抓取异常中还可以加入else分支,当没有抓取到异常时执行 try: xxxx except error,errorMsg: print(errorMsg) else: print(&quot;没有抓取到异常&quot;) finally: 释放资源操作 python中可以自定义异常,需要继承Error或者Exception抛异常,python使用raise关键字抛异常,类似于java的throw]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[python学习]]></title>
      <url>%2F2016%2F02%2F22%2Fpython%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[python注释 单行注释以#开头,#右边的都是注释内容#打印hello worldprint(“hello world”) 多行注释使用三个单引号括起来的内容就是多行注释‘’’ 打印hello world‘’’print(“hello world”) python对中文的支持如果在文件中使用了中文,直接运行的话会报错,这是可以在程序上方加上一行coding=utf-8或者coding=gbk,具体编码格式怎么写根据你的文件编码确定 python变量以及类型python中定义变量方式为: 变量名 = 值 不需要指定具体的数据类型 但是python中还是有数据类型的,分为以下几种Numbers(数字) Boolean布尔类型 String字符串 List列表 Tuple元组 Dictionary字典Numbers具体还分为int 有符号整型 long 长整型(也可以代表八进制和十六禁止) float 浮点类型 complex 复数Boolean具体分为True 和 False 那么该怎么知道一个变量具体的数据类型呢在python中,只要定义了一个变量,而且它有数据,那么它的类型就已经确定了,不需要去主动说明具体类型,系统会自动辨别可以使用type 变量的名字,来查看变量的类型 python标识符python中的标识符和其他语言要求的规则一样,有字母数字下划线组成且数字不能开头,并且区分大小写 python的关键字大致上和其他语言差不多可以通过import keywordkeyword.kwlist查看当前python版本里的关键字 python的格式化输出和c语言很像,可以在字符串使用%数据类型进行格式化输出,因为python中的+不像java中可以充当连接符.当其他数据类型加到字符串中,可以使用格式化符进行格式化输出age = 18name = “xiaohua”print(“我的姓名是%s,年龄是%d”%(name,age)) 常用的格式符号%c 字符%s 通过str()字符串转换来格式化%i 有符号十进制整数%d 有符号十进制整数%u 无符号十进制整数%o 八进制整数%x 十六进制整数(小写字母)%X 十六进制整数(大写字母)%e 索引符号(小写 ‘e’)%E 索引符号(大写 ‘e’)%f 浮点实数%g %f和%e的简写%G %f和%E的简写 换行输出 \nprint(“123456—–”) #会在一行显示print(“123456\n—–”) #\n后面的内容会在下一行显示 获取键盘输入python2中获取键盘输入的是raw_input函数,用法如下:password = raw_input(“请输入密码:”)print ‘您刚刚输入的密码是:’,password 还有input函数也可以获取,用法与raw_input类型,但是input会将传入的值当作表达式执行,要是不能执行就会报错 python3中获取键盘输入的只有input函数,与python2的raw_input函数功能一样 python的运算符算术运算符:+ - / // % 需要注意的是python的/结果是个浮点数,//类似于其他语言的/,是幂运算,比如10的20次方就是用10*20来表示 赋值运算符 =python中支持同时赋值给多个变量 a,b = 1,2 复合赋值运算符 += -= = /= %= *= //= 用法和其他语言一样 常用的数据类型转换int(x[,base]) 将x转换为一个整数long(x,[,base]) 将x转换为一个长整数float(x) 将x转换到一个浮点数complex(real[,imag]) 创建一个复数str(x) 将对象x转换为字符串repr(x) 将对象x转换为表达式字符串eval(str) 用来计算在字符串中的有效Python表达式,并返回一个对象tuple(s) 将序列s转换为一个元组list(s) 将序列s转换为一个列表chr(x) 将一个整数转换为一个字符unichr(x) 将一个整数转换为unicode字符ord(x) 将一个字符转换为它的整数值hex(x) 将一个整数转换为一个十六进制字符串oct(x) 将一个整数转换为一个八进制字符串 python中的判断if 要判断的条件: 条件成立时,要做的事 例子 从键盘获取自己的年龄,判断是否大于或者等于18岁,如果满足就输出”哥,已成年,网吧可以去了”age = input(“请输入你的年龄”)age = int(age)if age &gt;= 18: print(“哥,已成年,网吧可以去了”)else: print(“你还没有成年,等长大再去网吧吧”) 值得注意的是,input获取到的数据是字符串,需要使用int()函数将获取到值转成int python的关系运算符== != &lt;&gt; &gt; &gt;= &lt; &lt;=其中&lt;&gt;类似于!= python的逻辑运算符and or not python的判断结构有以下几种 1 . if 判断条件: 操作 2. if 判断条件: 操作 else : 操作 3. if 判断条件: 操作 elif 判断条件: 操作 elif 判断条件: 操作 else: 操作 第三种类似于java的 if else if else结构python的判断结构也是可以嵌套的 python的循环结构while 循环条件: 操作用发和其他语言一样 python中的for循环用法为 for 变量名 in 序列python中的for循环可以遍历一切可以遍历的数据python中for和while都可以加上else分支,当没有数据时执行else分支 python中的break和continue关键字用法和java一样break和continue都只能用于循环结构中,并且在循环多层嵌套的情况在,只对最近一层循环有效 python中的字符串在python中,被单引号或者双引号括起来的内容就是字符串.三引号括起来的内容是多行注释 python中的索引和切片索引和其他语言一样,都是从0开始不过python中还有另外一个用法叫切片切片是指对操作的对象截取其中一部分的操作.字符串,列表,元组都支持切片操作切片的语法:[起始:结束:步长]注意:选取的区间属于左闭右开型,即从”起始”位开始,到”结束”位的前一位结束(不包含结束位本身) 比如取字符串前三个字符name = ‘abcdef’print(name[0:3])实现倒序输出name = ‘abcdef’print(name[-1:0:-1]) 字符串常见操作 find检测str是否包含在mystr中,如果是返回开始的索引值,否则返回-1mystr.find(str,start=0,end=len(mystr))如果不指定起始和终点值,默认是查询全部 index跟find()方法一样,只不过如果str不在 mystr中会报一个异常.mystr.index(str,start=0,end=len(mystr)) count返回str在start和end之间 在mystr里面出现的次数mystr.count(str,start=0,end=len(mystr)) replace把mystr中的str1替换成str2,如果count指定,则替换不超过count次.mystr.replace(str1,str2,mystr.count(str1))不指定次数的话,默认是将mystr中的所有str1都替换成str2 split以str为分隔符切片mystr,如果maxsplit有指定值,则仅分隔maxsplit次mystr.split(str=””,2)指定2则会分隔两次,生成三个子字符串 capitalize把字符串的第一个字符大写mystr.capitalize()“hello”.capitalize() –&gt; Hello title把字符串的每个单词首字母大写“hello world”.title() –&gt; Hello World startswith检查字符串是否以指定字符串开头,是则返回True,否则返回False,区分大小写mystr = ‘hello world’mystr.startswith(‘hello’) –&gt; Truemystr.startswith(‘Hello’) –&gt; False endswith检查字符串是否以指定字符串结束,如果是返回True,否则返回False,区分大小写,用法和startswith一样 lower将字符串中的所有大写字符转换为小写“HELLO world”.lower() –&gt; hello world upper将字符串中的所有小写字符转换为大写“hello world”.upper() –&gt; HELLO WORLD ljust返回一个原字符串左对齐,并使用空格填充至长度width的新字符串mystr.ljust(width)“hello”.ljust(10) –&gt; “hello “ (在右边填充了五个空格) rjust返回一个原字符串右对齐,并使用空格填充至width的新字符串mystr.rjust(width)“hello”.rjust(10) –&gt; “ hello” (在左边填充了五个空格) center返回一个原字符串居中,并使用空格填充至长度width的新字符串mystr.center(width)“hello”.center(10) –&gt; “ hello “ (在左边填充了两个空格,在右边填充了三个空格) lstrip删除mystr左边的空白字符mystr.lstrip()“ hello”.lstrip() –&gt; “hello” rstrip删除mystr右边的空白字符mystr.rstrip()“hello “.rstrip() –&gt; “hello” strip删除mystr字符串两端的空白字符mystr.strip()“ hello “.strip() –&gt; “hello” rfind类似于find()函数,不过是从右边开始查找mystr.rfind(str,start=0,end=len(mystr)) rindex类似于index()函数,不过是从右边开始查找mystr.rindex(str,start=0,end=len(mystr)) partition把mystr以str分割成三部分,str前,str和str后mystr.partition(str)“hello world python2 and python3”.partition(‘python’) –&gt; (‘hello world ‘,’python’,’2 and python3’) rpartition类似于partition()函数,不过是从右边开始mystr.rpartition()“hello world python2 and python3”.rpartition(‘python’) –&gt; (“hello world python2 and “,”python”,”3”) splitlines按照行分割,返回一个包含各行内容作为元素的列表mystr.splitlines()“hello\nworld”.splitlines() –&gt; [‘hello’,’world’] isalpha如果mystr所有字符都是字母,则返回True,否则返回Falsemystr.isalpha()“abc”.isalpha() –&gt; True“123”.isalpha() –&gt; False isdigit如果mystr只包含数字则返回True,否则返回Falsemystr.isdigit()“abc”.isdigit() –&gt; False“123”.isdigit() –&gt; True isalnum如果mystr所有字符都是字母或者数字,则返回True,否则返回Falsemystr.isalnum()“123”.isalnum() –&gt; True“abc”.isalnum() –&gt; True“123abc”.isalnum() –&gt; True“abc nttt1”.isalnum() –&gt; False isspace如果mystr中只包含空格,则返回True,否则返回Falsemystr.isspace()“ “.isspace() –&gt; True“abc “.isspace() –&gt; False join在列表中的每一个元素后面插入mystr,最后一个元素后面不插入mystr.join(arr)arr = [‘my’,’name’,’is’,’python’]‘ ‘.join(arr) –&gt; ‘my name is python’ python中的列表类似于java中的list和数组的混合体列表的格式变量名=[元素一,元素二,元素三] arr = [1,2,3,4,5,”上山打老虎”]python中的列表元素可以是不同类型的 获取列表中的元素可以通过索引或者切片,索引从0开始arr[0] –&gt; 1 遍历列表通过for循环 for i in arr: print(i) 将会在键盘上将列表中的所有元素依次打印出来 通过while循环length = len(arr) #通过len函数获得列表的长度i = 0 #定义一个计数器,充当索引 while i &lt; length: print(arr[i]) i += 1 #计数器加1,直到超过len,结束循环 也会依次打印列表中的元素 python列表的相关操作列表中存放的数据是可以进行操作的,例如”增”,”删”,”改” 增加元素append通过append可以向列表添加元素 arr = [1,2,3,4] arr.append(5) for i in arr: print(i) append添加的元素会在列表后面追加 extend通过extend可以将另一个集合中的元素逐以添加到列表中arr2 = [6,6]arr.append(arr2) #直接append列表,会把列表当作一个元素加入arr.extend(arr2) #用extend可以将arr2中的元素一个一个添加到arr中 insert在指定位置index前插入元素object 用法:arr.insert(index,object)a = [0,1,2]a.insert(1,3) #在索引1位置插入3 结果为[0,3,1,2] 修改元素通过下标来确定要修改的是哪个元素,然后进行修改arr = [0,1,2]arr[1] = 3 #将列表arr索引1位置的元素修改为3 结果为[0,3,2] 查找元素in 如果列表中存在该元素,则返回True,否则返回Falsenot in 如果列表中不存在该元素,则返回True,否则返回False 用法arr = [1,2,3]if 1 in arr: #判断arr中存在1不 print(“有”)if 1 not in arr: #判断arr中不存在1不 print(“没有”) #结果是有 在列表中也可以用index和count方法,用法和字符串中的相同arr = [1,2,3]arr.index(1) #获得列表arr中元素值为1的索引,结果是0arr.count(1) #获得列表arr中元素值为1出现的次数.结果是1 删除元素del 根据下标进行删除pop 删除最后一个元素remove 根据元素的值进行删除 arr = [1,2,3,4,5]del arr[0] #删除了列表中的索引0处的元素 结果为[2,3,4,5]arr.pop() #删除了列表中的最后一个元素 结果为[2,3,4]arr.remove(3) #删除列表中元素值为3的元素 结果为[2,4] (列表中如果有多个要删除的元素,只会删除从左边起第一个匹配到的元素) 列表排序sort sort方法是将list按特定顺序重新排列,默认为从小到大,参数reverse=True,可改为倒序,由大到小reverse方法是将list逆置 arr = [1,4,3,2]a.reverse() #将列表反转,结果为 [2,3,4,1]a.sort() #将列表从小到大排列,结果为 [1,2,3,4]a.sort(reverse=True) #将列表从大到小排列,结果为 [4,3,2,1] 列表的嵌套列表中的元素又是一个列表,那么这就是列表的嵌套直接访问列表中的列表可以像java中访问二维数组一样arr = [[1,2],[3,4],[5,6]]arr[0][0] #访问外面列表的第一个元素列表中的第一个元素,结果为1 元组元组与列表类似,不过元组中的数据是不可以更改的,使用小括号括起来的是元组,列表是使用中括号括起来的aTuple = (1,2) 访问元组中的数据和访问列表一样,指定索引就行,索引从0开始aTuple[0] #访问元组索引为0处的元素 结果为1 一旦定义了元组,元组内的数据就不可以更改了,增加删除修改都不可以 元组的内置函数有count,index,用法与列表和字符串相同aTuple.index(1) #获取元素值为1的索引,当有多个元素值为1时,返回从左起,匹配的第一个 结果为0aTuple.count(1) #获取元组中元素值为1的个数 结果为1 字典python的字典类似于java中的map,由键值对组成,用花括号括起来,键值对用:隔开,键值对之间用,隔开dict = {“a”:1,”b”:2,”c”,3} 获取字典中的值,不像元组和列表那样使用索引,而是使用键dict[“a”] #获取字典中键为a的值 结果为1 若访问不存在的键,则会报错如 dict[“d”] #因为字典中不存在d这个键,所以这样写会报错 当我们不确定字典中有没有这个键的时候,可以使用get方法,不会报错v = dict.get(“d”) #字典中没有d这个键,用get方法获取到的值v,是Nonetype(v) #结果是使用get方法的时候还可以设置默认值,当指定的键不存在时,就会返回默认值v = dict.get(“d”,4) #因为dict字典中没有d这个键,而又设置了默认值为4,则v的值为4 字典的操作修改元素列表是通过索引确定元素进而进行修改,字典是通过键确定元素然后进行修改dict[“a”] = 5 #修改字典中键为a的值为5,则字典为 {“a”:5.”b”:2,”c”,3}列表中对不存在的索引进行修改会报错,而字典对不存在的键进行修改操作(不如说是赋值操作),会将这个不存在的键和值添加到字典中 删除元素del 删除指定的元素或者删除字典clear() 清空字典中的元素 del dict[“a”] #会将字典中键为a的元素删除del dict 直接删除dict字典,再次访问会报错dict.clear() #清空字典,删除字典中的所有元素,但是字典dict还是存在的 可以访问 结果为{} 字典的常用方法 len获取字典中的键值对个数dict = {“a”:1,”b”:2,”c”:3}len(dict) #结果为3 keys返回一个包含字典所有key值的列表dict.keys() #结果为 [“a”,”b”,”c”] values返回一个包含字典所有value的列表dict.values() #结果为[1,2,3] items返回一个包含所有(键,值)元组的列表dict.items() #结果为[(“a”,1),(“b”,2),(“c”,3)] has_key如果key在字典中,返回True,否则返回Falsedict.has_key(“a”) #有a这个键,返回Truedict.has_key(“d”) #没有d这个键,返回False python中的遍历通过for xx in yyy: 的语法结构,可以遍历字符串,列表,元组,字典等数据结构 字典的遍历 遍历字典的key(键)for key in dict.keys(): print(key) #结果是a b c 遍历字典的value(值)for value in dict.values(): print(value) #结果是1 2 3 遍历字典的项(元素)for item in dict.items(): print(item) #结果是(“a”,1) (“b”,2) (“c”,3) 遍历字典的key-value(键值对)for key,value in dict.items(): print(“key=%s,value=%s”%(key,value)) #结果是 key=a,value=1 key=b,value=2 key=c,value=3 如何实现带索引的遍历 使用计数器充当索引arr = [1,2,3,4,5]i = 0for a in arr: print(“%d,%d”%(i,a)) 使用enumerate()方法for i,a in enumerate(arr): print(“%d,%d”%(i,a)) 公共方法运算符 python表达式 结果 描述 支持的数据类型 + [1,2]+[3,4] [1,2,3,4] 合并 字符串,列表,元组 * &quot;Hi!&quot; * 4 [&quot;Hi!&quot;,&quot;Hi!&quot;,&quot;Hi!&quot;,&quot;Hi&quot;] 复制 字符串,列表,元组 in 3 in (1,2,3) True 元素是否存在 字符串,列表,元组,字典 not in 4 not in (1,2,3) True 元素是否不存在 字符串,列表,元组,字典 python内置函数cmp(item1,item2) 比较两个元素值len(item) 计算容器中元素个数max(item) 返回容器中元素最大值min(item) 返回容器中元素最小值del(item) 删除变量注意:cmp在比较字典数据时,先比较键,再比较值. cmp函数是通过ascII码进行比较的 len在操作字典数据时,返回的是键值对个数 del方法可以不加空格 直接del item python中的引用和java一样python中可以通过id()方法判断两个元素是否是同一个 可变类型与不可变类型可变类型,值可以改变: 列表 字典不可变类型,值不可以改变: 数值类型(int long boolean float) 字符串 元组 python中的函数定义函数 def 函数名(): 代码 def printStr(): print(“Hello world”)调用函数 直接函数名() 调用 printStr() 函数的文档注释在函数代码块第一行写的字符串会被认为是文档注释def add(a,b): “打印两个数的和” print(“和为%d”%(a+b)) 通过help()方法可以获得函数的文档注释help(add) python的函数和java函数 除了定义写法不同,其他都一样定义带参数的函数,传入参数时要是不指定传给具体的形参,传入的值按照形参的顺序依次赋值add(1,2) 1–&gt;a 2–&gt;badd(b=2,a=1) 可以这样给具体的形参赋值add(b=2,1) 当指定具体的形参了,后面的参数都需要指定 不然会报错SyntaxError: positional argument follows keyword argument 函数的返回值def add(a,b) return a+b在函数内部使用return关键字返回了一个值,那么这个函数就有返回值了,可以在调用的时候定义一个变量接收sum = add(1,2) sum的值为3 函数嵌套 在函数内部还可以调用其他函数 python中的局部变量和全局变量和java中的相仿当在方法中相用全局变量时,需要在变量名前加上global关键字,以标明这个变量是全局变量 在函数中不加global无法修改全局变量的原因是,在函数内部无法更改全局变量的指向..所以可变数据类型不加global也可以进行修改,以为地址值并不会改变 而不可变类型值改变就是地址值改变,所以要加上global python中的函数可以返回多个值,本质是返回了一个元组,元组中的元素是这多个值 python中还可以声明缺省参数,当没有为该形参传入值时,使用默认值def printInfo(name,age=25): print(“name:%s”%name) print(“age:%s”%age) printInfo(“小王”) #因为没有为age传入值,所以使用默认值25 打印 小王 25printInfo(“小吴”,20) #age形参传入了参数,使用传入的参数 打印 小吴 20 需要注意的是,缺省参数后面不能跟没有默认值的形参,不然会报错 所以缺省参数都会放在最后面def printInfo(name,age=25,phone) print.. 上面定义的函数会报错 ,因为在缺省参数后面有没有定义缺省值的参数 python的不定长参数的意义同java的可变参数一样,不过python的不定长参数比java的复杂的多def fun(a,b,c,**d) 接收普通参数,所有参数形成一个元组 **接收键值对,所有参数形成一个字典 fun(1,2,3,4,5,a=1,b=2,c=3) 形参c为(3,4,5) 形参d为{“a”:1,”b”:2,”c”:3} 最前面两个参数1,2赋值给a,b t = (1,1,1)f = {“a”:1,”b”:2}fun(1,2,t,f)fun(1,2,t,f) 上面两种直接传入元组和字典的方式第一种 指定了t是传个元组的,f是传给字典的,所以c = t d = f第二种 没有指定,又t和f都是普通参数 不是键值对 所以 c = (t,f) 而d为空 python中参数传递类似与javapython中的不可变类型传递类似于java中的基本数据类型,所以是值传递python中的可变类型传递类似于java中的引用数据类型,所以是引用传递(本质也是值传递) python中的匿名函数用lambda关键字能创建小型匿名函数.匿名函数主要是省略了def声明函数语法:lambda [arg1[,arg2,…argn]]:expression如下案例sum = lambda arg1,arg2:arg1 + arg2lambda函数能接收任何数量的参数 但只能返回一个表达式的值匿名函数不能直接调用print,因为lambda需要一个表达式]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[net.sf.ehcache.CacheException异常]]></title>
      <url>%2F2016%2F02%2F20%2FehcacheManage%E5%BC%82%E5%B8%B8%E8%A7%A3%E5%86%B3%2F</url>
      <content type="text"><![CDATA[异常及产生原因今天启动项目报了以下错误 PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;realm&apos; threw exception; nested exception is org.apache.shiro.cache.CacheException: net.sf.ehcache.CacheException: Another unnamed CacheManager already exists in the same VM. Please provide unique names for each CacheManager in the config or do one of following: 1. Use one of the CacheManager.create() static factory methods to reuse same CacheManager with same name or create one if necessary 2. Shutdown the earlier cacheManager before creating new one with same name. The source of the existing CacheManager is: InputStreamConfigurationSource [stream=java.io.BufferedInputStream@38598a4f] org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;shiroFilter&apos; defined in class path resource [applicationContext.xml]: Cannot resolve reference to bean &apos;securityManager&apos; while setting bean property &apos;securityManager&apos;; nested exception is org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;securityManager&apos; defined in class path resource [applicationContext.xml]: Error setting property values; nested exception is org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are: PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;realm&apos; threw exception; nested exception is org.apache.shiro.cache.CacheException: net.sf.ehcache.CacheException: Another unnamed CacheManager already exists in the same VM. Please provide unique names for each CacheManager in the config or do one of following: 1. Use one of the CacheManager.create() static factory methods to reuse same CacheManager with same name or create one if necessary 2. Shutdown the earlier cacheManager before creating new one with same name. The source of the existing CacheManager is: InputStreamConfigurationSource [stream=java.io.BufferedInputStream@38598a4f] at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:359) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveValueIfNecessary(BeanDefinitionValueResolver.java:108) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1481) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:202) at org.springframework.context.support.PostProcessorRegistrationDelegate.registerBeanPostProcessors(PostProcessorRegistrationDelegate.java:240) at org.springframework.context.support.AbstractApplicationContext.registerBeanPostProcessors(AbstractApplicationContext.java:687) at org.springframework.context.support.AbstractApplicationContext.refresh(AbstractApplicationContext.java:523) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:139) at org.springframework.context.support.ClassPathXmlApplicationContext.&lt;init&gt;(ClassPathXmlApplicationContext.java:83) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:44) at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:15) at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:41) at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:20) at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:263) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:69) at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:48) at org.junit.runners.ParentRunner$3.run(ParentRunner.java:231) at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:60) at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:229) at org.junit.runners.ParentRunner.access$000(ParentRunner.java:50) at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:222) at org.junit.runners.ParentRunner.run(ParentRunner.java:292) at org.junit.runner.JUnitCore.run(JUnitCore.java:157) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:119) at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:42) at com.intellij.rt.execution.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:234) at com.intellij.rt.execution.junit.JUnitStarter.main(JUnitStarter.java:74) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:606) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:144) Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;securityManager&apos; defined in class path resource [applicationContext.xml]: Error setting property values; nested exception is org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are: PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;realm&apos; threw exception; nested exception is org.apache.shiro.cache.CacheException: net.sf.ehcache.CacheException: Another unnamed CacheManager already exists in the same VM. Please provide unique names for each CacheManager in the config or do one of following: 1. Use one of the CacheManager.create() static factory methods to reuse same CacheManager with same name or create one if necessary 2. Shutdown the earlier cacheManager before creating new one with same name. The source of the existing CacheManager is: InputStreamConfigurationSource [stream=java.io.BufferedInputStream@38598a4f] at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1518) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.populateBean(AbstractAutowireCapableBeanFactory.java:1226) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:543) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:482) at org.springframework.beans.factory.support.AbstractBeanFactory$1.getObject(AbstractBeanFactory.java:306) at org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:230) at org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:302) at org.springframework.beans.factory.support.AbstractBeanFactory.getBean(AbstractBeanFactory.java:197) at org.springframework.beans.factory.support.BeanDefinitionValueResolver.resolveReference(BeanDefinitionValueResolver.java:351) ... 43 more Caused by: org.springframework.beans.PropertyBatchUpdateException; nested PropertyAccessExceptions (1) are: PropertyAccessException 1: org.springframework.beans.MethodInvocationException: Property &apos;realm&apos; threw exception; nested exception is org.apache.shiro.cache.CacheException: net.sf.ehcache.CacheException: Another unnamed CacheManager already exists in the same VM. Please provide unique names for each CacheManager in the config or do one of following: 1. Use one of the CacheManager.create() static factory methods to reuse same CacheManager with same name or create one if necessary 2. Shutdown the earlier cacheManager before creating new one with same name. The source of the existing CacheManager is: InputStreamConfigurationSource [stream=java.io.BufferedInputStream@38598a4f] at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:121) at org.springframework.beans.AbstractPropertyAccessor.setPropertyValues(AbstractPropertyAccessor.java:75) at org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.applyPropertyValues(AbstractAutowireCapableBeanFactory.java:1514) ... 51 more 之前项目运行一直没问题,今天往项目中整合了activiti,运行activiti测试案例就报了上面的错.根据异常信息可以得出是缓存管理器出了问题..ehcache缓存是在项目整合shiro加入的,配置如下 &lt;!--配置安全管理器--&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;!--注入缓存管理器--&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;!--在安全管理器中配置自定义的Realm类--&gt; &lt;property name=&quot;realm&quot; ref=&quot;contextRealm&quot;/&gt; &lt;/bean&gt; &lt;!--缓存管理器--&gt; &lt;bean id=&quot;cacheManager&quot; scope=&quot;singleton&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManagerConfigFile&quot; value=&quot;classpath:ehcache.xml&quot;/&gt; &lt;/bean&gt; 解决方法由异常信息可以看出,内存中已经有一个ehcacheManager了,现在又试图根据相同的配置文件生成一个新的ehcacheManager,进而报错 解决该异常方法如下 在项目中新增如下依赖 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;4.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; 依赖版本根据项目spring环境选择 然后更改缓存管理器配置如下 &lt;!--配置安全管理器--&gt; &lt;bean id=&quot;securityManager&quot; class=&quot;org.apache.shiro.web.mgt.DefaultWebSecurityManager&quot;&gt; &lt;!--注入缓存管理器--&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;cacheManager&quot;/&gt; &lt;!--在安全管理器中配置自定义的Realm类--&gt; &lt;property name=&quot;realm&quot; ref=&quot;contextRealm&quot;/&gt; &lt;/bean&gt; &lt;!--缓存管理器--&gt; &lt;bean id=&quot;cacheManager&quot; scope=&quot;singleton&quot; class=&quot;org.apache.shiro.cache.ehcache.EhCacheManager&quot;&gt; &lt;property name=&quot;cacheManager&quot; ref=&quot;ehcache&quot;/&gt; &lt;/bean&gt; &lt;!--缓存工厂--&gt; &lt;bean id=&quot;ehcache&quot; class=&quot;org.springframework.cache.ehcache.EhCacheManagerFactoryBean&quot;&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:ehcache.xml&quot;/&gt; &lt;property name=&quot;shared&quot; value=&quot;true&quot;/&gt; &lt;/bean&gt; 核心是新增一个缓存工厂bean,设置其shared属性为true.这个配置的含义是当运行时有地方需要缓存管理器时,直接使用当前的就行,不需要新生成,也就不会报上面的错了.]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[intellij下activiti designer插件安装及使用]]></title>
      <url>%2F2016%2F02%2F17%2Fintellij%E4%B8%8Bactiviti%20designer%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[intellij idea下activiti designer插件安装我的intellij版本为2016.1.1. 点击上方工具栏file–&gt;setting打开设置界面,或者使用ctrl+alt+s快捷键打开,然后点击Plugins,进去插件页面. intellij下的activiti designer插件名为actiBPM.如下图,在搜索框输入名称. 然后点击红线处,进入下图界面,点击install进行下载 下载完成之后重启intellij,actiBMP插件就安装成功了 actiBPM插件使用插件安装完成之后,在项目目录右键,点击new,就会看到文件列表中出现了一个BPMN file文件,点击即可新建一个bpmn文件 不过我的这个intellij版本新建会有一个小bug,如下图 输入名称之后,点击ok,并没有任何反应,但是其实文件已经新建成功,点击X或者Cancel即可以看到目录下生成了一个a.bpmn文件 点击文件即可进入画图面板,可以进行流程设计了 右边选择图标,左边填写信息 根据bpmn文件生成png文件在eclipse下的activiti designer插件可以在设置里设置保存bmpn文件即生成png文件.但是intellij却没有这功能,虽然在插件页面,actiBPM作者说了一个方法,但是并没有啥用 百度了好久,学会了一个生成png图片的方法,虽然比较麻烦 在新建的文件上右键,选择Refactor–&gt;Rename,或者直接alt+shift+r快捷键打开重命名界面,将后缀名改为xml 然后再右键刚改完名的文件,在下方点击Diagrams 选择第一个Show BPMN 2.0 Diagrams后即可打开图片界面,点击下方的红线处,选择目录,填写好文件名,点击ok,即可在选择的目录下生成所画的流程图对应的png图片 解决生成的图片乱码问题如果生成的图片上面字体乱码的话,则可以按照下面操作解决图片乱码问题 第一种: 直接打开xml文件,进入文件将乱码的字体改回来,再重新生成图片即可 第二种: 进入intellij的安装目录下的bin目录,找到以下两个文件 打开这两个文件,将以下配置复制粘贴到两个文件的末尾,保存.然后重启intellij,即可解决图片的中文乱码问题 -Dfile.encoding=UTF-8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Eclipse整合svn步骤]]></title>
      <url>%2F2016%2F02%2F17%2FEclipse%E6%95%B4%E5%90%88svn%E6%AD%A5%E9%AA%A4%2F</url>
      <content type="text"><![CDATA[1) 点击eclipse的Help–&gt;Install New Software，点击add，并输入name：Subclipse 1.6.xlocation：http://subclipse.tigris.org/update_1.6.x 2) 点击next, 出现的选项全部选中 3) 等待自动下载 4) 自动下载完成以后出现 5) finish, 剩下的全部无脑安装]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux学习]]></title>
      <url>%2F2016%2F02%2F14%2Flinux%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[linux目录/： 根目录， 一般根目录下只存放目录， 在Linux下有且只有一个根目录。 所有的东西 都是从这里开始。 当你在终端里输入“/home”， 你其实是在告诉电脑， 先从/（ 根目 录） 开始， 再进入到home目录。 /bin、 /usr/bin: 可执行二进制文件的目录， 如常用的命令ls、 tar、 mv、 cat等。 /boot： 放置linux系统启动时用到的一些文件， 如Linux的内核文件： /boot/vmlinuz,系统引导管理器： /boot/grub。 /dev： 存放linux系统下的设备文件， 访问该目录下某个文件， 相当于访问某个设备， 常见的是挂载光驱 mount /dev/cdrom /mnt。 /etc： 系统配置文件存放的目录， 不建议在此目录下存放可执行文件， 重要的配置文 件有 /etc/inittab、 /etc/fstab、 /etc/init.d、 /etc/X11、 /etc/sysconfig、 /etc/xinetd.d。 /home： 系统默认的用户家目录， 新增用户账号时， 用户的家目录都存放在此目录 下， ~表示当前用户的家目录， ~edu 表示用户 edu 的家目录。 /lib、 /usr/lib、 /usr/local/lib： 系统使用的函数库的目录， 程序在执行过程中， 需要调 用一些额外的参数时需要函数库的协助。 /lost+fount： 系统异常产生错误时， 会将一些遗失的片段放置于此目录下。 /mnt: /media： 光盘默认挂载点， 通常光盘挂载于 /mnt/cdrom 下， 也不一定， 可以选 择任意位置进⾏挂载。 /opt： 给主机额外安装软件所摆放的目录。 /proc： 此目录的数据都在内存中， 如系统核心， 外部设备， 网络状态， 由于数据都存 放于内存中， 所以不占用磁盘空间， 比较重要的目录有 /proc/cpuinfo、 /proc/interrupts、 /proc/dma、 /proc/ioports、 /proc/net/* 等。 /root： 系统管理员root的家目录。 /sbin、 /usr/sbin、 /usr/local/sbin： 放置系统管理员使用的可执行命令， 如fdisk、 shutdown、 mount 等。 与 /bin 不同的是， 这几个目录是给系统管理员 root使用的命 令， 一般用户只能&quot;查看&quot;而不能设置和使用。 /tmp： 一般用户或正在执行的程序临时存放文件的目录， 任何人都可以访问， 重要数 据不可放置在此目录下。 /srv： 服务启动之后需要访问的数据目录， 如 www 服务需要访问的网页数据存放在 /srv/www 内。 /usr： 应用程序存放目录， /usr/bin 存放应用程序， /usr/share 存放共享数据， /usr/lib 存放不能直接运行的， 却是许多程序运行所必需的一些函数库文件。 /usr/local: 存放 软件升级包。 /usr/share/doc: 系统说明文件存放目录。 /usr/share/man: 程序说明文件 存放目录。 /var： 放置系统执行过程中经常变化的文件， 如随时更改的日志文件 /var/log， /var/log/message： 所有的登录文件存放目录， /var/spool/mail： 邮件存放 的目录， /var/run:程序或服务启动后， 其PID存放在该目录下。 liunx常用指令man命令使用man命令查询帮助文档时,可以使用以下快捷键f 向前翻一页b 向后翻一页(和空格键一样的效果)Enter键 向下滚动一行/word 在文档中搜索word字符串 ls命令ls 查看文件命令,类似于dos的dir命令. 代表当前目录 ..代表上一级目录-a 显示指定目录下所有子目录与文件,包括隐藏目录-l 以列表方式显示文件的详细信息-h 配合-l以人性化的方式显示文件大小(直接使用-h没啥效果) 文件属性含义 1 2 3 4 5 6 7 -rw-r--r-- 1 root root 14 11月 24 01:31 file3 1: 第一个字符代表文件的类型,后面9位是文件的权限,前三位是文件创建用户的权限,中间三位是文件创建用户所属组的权限,后面三位是其他用户的权限.2: 文件的硬链接数3: 文件的创建用户,拥有者4: 文件创建用户所属的组5: 文件的大小6: 文件的创建时间7: 文件名 linux命令中通配符的使用可以使用* 来匹配多个文件 代表文件名中的所有字符ls te 查找文件名以te开头的文件ls html 查找文件名以html结尾的文件? 代表文件名中任意一个字符ls ?.c 查找文件名第一个字符任意,后缀为.c的文件ls a.? 查找文件名最后一个字符任意,前面是a.的文件[] [和]将字符组括起来,表示可以匹配字符组中的任意一个,-用于表示字符范围[abc] 匹配abc中的任意一个[a-f] 匹配从a到f范围内的任意一个字符ls [a-f] 查找文件名以a到f中任意一个字符开头的文件ls a-f 查找文件名为a-f的文件,当-处于方括号之外,失去通配符的作用\ 如果要使通配符作为普通字符使用,可以在其前面加上转义字符.?和处于方括号内时不用使用转义字符就失去通配符的作用 输出重定向.&gt;输出重定向命令可以将本应该显示到终端的内容输出到文件中ls &gt; test.txt(如果该文件不存在就会自动创建)打开该文件就可以看到本应该显示在终端上的内容 cat命令cat 可以查看文件内容当内容过多时,会出现文件内容在屏幕上快速滚动这时可以使用more 命令进行分屏显示more命令展示的内容 可以使用man命令下的那些快捷键协助查看 |管道符| 管道符一个命令的输出可以当作另一个命令的输入如果目录下子文件和目录比较多的话,就可以用下面这个命令,将ls -lh的命令结果在页面上分屏显示ls -lh | more clearclear命令清空屏幕,和dos的cls命令效果一样.假清屏,之前的内容还在上方,还可以使用ctrl+l快捷键. cdcd命令切换工作目录cd后面可以跟绝对路径,也可以跟相对路径cd 如果后面不跟任何目录,则会切换到当前用户的主目录(就是家目录,/home/用户目录),用户刚登录的时候,默认就在用户目录下cd ~ 切换到当前用户的主目录cd . 切换到当前目录cd .. 切换到上级目录cd - 可进入上次所在的目录,和windows的后退一样 pwdpwd 显示当前所在目录 mkdirmkdir 创建目录后面接要创建的目录名 mkdir test接-p参数可以递归创建目录 mkdir a/b/c -p值得注意的是,新建的目录不能和当前已经存在的目录或者文件重名,并且目录创建者在当前目录拥有写的权限 treetree命令 ,可以用树状图的形式显示指定目录下的目录结构 rmdirrmdir 删除目录需要注意:删除目录之前,目录得是空目录,目录下没有任何文件和目录,并且不能处于该目录下,要离开该目录,而且删除该目录的用户对该目录需要拥有写的权限 rmrm 删除文件或者目录参数:-i 以进行交互的方式执行,删除前会询问是否删除-f 强制删除,忽略不存在的文件,不会询问-r 递归的删除目录下的文件,删除文件夹的时候必须加上此参数 lnln 建立链接文件链接文件类似与windos的快捷方式分为硬链接和软链接区别就是删除源文件的时候,软链接会失效,无法使用,而硬链接可以继续使用,没有影响(删除源文件,软硬链接文件还会存在)ln 源文件 链接文件 –&gt; 建立一个硬链接ln -s 源文件 链接文件 –&gt; 建立一个软链接注意:如果软链接文件和源文件不在同一个目录下,源文件要使用绝对路径,不能使用相对路径 catcat命令除了可以显示文件内容外,还可以通过输出重定向将两个文件内容合并到一个文件中cat 文件1 文件2 &gt; 文件3 将文件1和文件2的内容合并到文件3中.&gt;代表将内容输出到文件3中,但是会将文件3中原有的内容覆盖掉,如果想保留文件3的内容,只是将合并内容追加到原有内容后面,则可以使用 &gt;&gt; 两个&gt;代表追加 grepgrep 文本搜索grep [-选项] ‘搜索内容串’ 文件名-v 显示不包含匹配文本的所有行(相当于求反)-n 显示匹配行及行号-i 忽略大小写grep搜索内容串可以是正则表达式grep常用正则表达式^a 行首,搜索以a开头的行;grep -n ‘^a’ 1.txtke$ 行尾,搜索以ke结束的行;grep -n ‘ke$’ 1.txt[Ss]igna[Ll] 匹配[]里中字符组中的其中一个字符. 点匹配任意一个字符,除了换行符,和上面通配符的?效果一样 findfind 文件查找用来在特定的目录下搜索符合条件的文件,也可以用来搜索特定用户属主的文件find ./ -name test.sh 查找当前目录下所有名为tesh.sh的文件 后面的文件名可以使用通配符,不过需要用单或双引号引起来find ./ -name ‘.sh’ 查找当前目录下所有名以.sh结尾的文件find ./ -name ‘[A-Z]‘ 查找当前目录下所有名以A到Z中的一个字符开头的文件 find 后面还可以加参数 查找满足某些条件的文件find /tmp -size 2M 查找/tmp目录下文件大小为2M的文件find /tmp -size +2M 查找/tmp目录下文件大小大于2M的文件find /tmp -size -2M 查找/tmp目录下文件大小小于2M的文件find ./ -size +4K -size -5M 查找当前目录下文件大小大于4k小于5M的文件find ./ -perm 0777 查找当前目录下权限为777的文件或者目录 cpcp 拷贝文件将给出的文件或者目录复制到另一个文件或目录中,相当于DOS下的copy命令常用选项参数-a 该选项通常在复制目录时使用,它保留链接,文件属性,并递归地复制目录,简单而言,保持文件原有属性-f 禁止交互式操作,如有覆盖也不会给出提示,相当于强制执行-i 交互式复制,在覆盖目标文件之前将给出提示要求用户确认-r 若给出的源文件是目录文件,则会递归复制该目录下的所有子目录和文件,目标文件必须为一个目录名-v 显示拷贝进度 mvmv移动文件 相当于windows的剪切mv命令除了可以移动文件或目录,还可以给文件或目录重命名常用选项参数-f 禁止交互式操作,如有覆盖也不会给出提示,相当于强制执行-i 交互式移动,如果移动的目录已经有同名文件,会给出提示要求用户确认是否覆盖-v 显示移动进度 tartar 归档管理,打包和解包计算机中的数据经常需要备份,tar是Unix和Linux中最常用的备份工具,此命令可以把一系列文件归档到一个大文件中,也可以把档案文件解开以恢复数据,tar使用格式tar [参数] 打包文件名 文件1,文件2,文件3tar命令很特殊,其参数前面可以不加-常用选项参数-c 生成档案文件,创建打包文件-v 列出归档解档的详细过程,显示进度-f 指定档案文件名称,f后面一定是.tar文件,所以必须放选项最后-t 列出档案中包含的文件-x 解开档案的文件注意:除了f需要放在参数的最后,其他参数的顺序任意 gzipgzip 文件压缩解压tar与gzip命令结合使用实现文件打包,压缩.tar只负责打包文件,但不压缩,用gzip压缩tar打包后的文件,其扩展名一般用xxx.tar.gzgzip使用格式如下gzip [选项] 被压缩文件 [压缩后的文件名] 不写压缩后的文件名默认是在压缩的文件名后加上.gz常用选项参数-d 解压-r 压缩所有子目录gzip -r test.tar test.tar.gz 等同于 gzip -r test.targzip -d test.tar.gz tar这个命令并没有压缩的功能,它只是一个打包的命令,但是在tar命令中增加一个选项(-z)可以调用gzip实现了一个压缩的功能,执行一个先打包后压缩的过程压缩用法: tar zcvf 压缩包包名 文件1,文件2tar cvzf test.tar.gz ./* 将当前目录下的所有文件打包压缩到test.tar.gz文件中 解压用法: tar zxvf 压缩包包名tar zxvf test.tar.gz解压时还可以加上一个参数 -C 将文件解压到指定目录tar zxvf test.tar.gz -C ./test 将文件解压到当前目录下的test文件夹中 bzip2bzip2 文件压缩解压bzip2是另一种压缩方式,用法和gzip一样,也可以结合tar命令使用,只用在tar命令中加一个选项参数-j,就可以实现用bzip2对文件进行压缩和解压操作压缩用法 tar -jcvf 压缩包包名 文件1,文件2,文件3解压用法 tar -jxvf 压缩包包名bzip2压缩的文件文件名一般为xxx.tar.bz2 zip,uzipzip,unzip 文件压缩解压通过zip压缩文件的目标文件不需要指定扩展名,默认扩展名为zip压缩文件: zip [r] 目标文件 源文件解压文件 unzip -d 解压后目录文件 压缩文件zip myzip * 将当前目录下的所有文件和目录压缩到myzip中unzip -d /test myzip.zip 将myzip解压到当前目录下的test文件夹下需要注意:当被压缩的文件中有失效的软链接,这个软链接并不会被加到压缩文件里 whichwhich 查看命令位置which ls 查看ls命令所在位置当输入了一个不存在的命令,将什么都不返回 whoamiwhoami 查看当前用户用该命令可以查看当前系统当前帐号的用户名,可通过cat /etc/passwd查看系统用户信息 whowho 查看登录用户用于查看当前所有登录系统的用户信息常用选项参数:-m或am I 只显示运行who命令的用户用户名,登录终端和登录时间(默认选项)-q或–count 只显示用户的登录帐号和登录用户的数量-u或–heading 显示列标题 exitexit 退出登录账户如果是图形界面,退出当前终端如果是使用ssh远程登录,退出登录账户如果是切换后的登陆用户,退出则返回上一个登陆帐号 useradduseradd 添加用户帐号在unix/linux中添加用户帐号可以使用adduser或useradd,因为adduser命令是指向useradd命令的一个链接,因此,这两个命令的使用格式完全一样使用格式: useradd [参数] 新建用户帐号常用参数选项:-d 指定用户登录系统时的主目录,如果不是该参数,系统自动在/home目录下建立与用户名同名的目录为主目录-m 自动建立目录-g 指定组名称相关说明:linux每个用户都要有一个主目录,主目录就是第一次登录系统,用户的默认当前目录(/home/用户名)每一个用户必须有一个主目录,所以用useradd创建用户的时候,一定给用户指定一个主目录用户的主目录一般要放到根目录的home目录下,用户的主目录和用户名是相同的如果创建用户的时候,不指定组名,那么系统会自动创建一个和用户名一样的组名用法useradd -d /home/abc abc -m 创建abc用户,如果/home/abc目录不存在,就自动创建这个目录,同时用户属于abc组useradd -d /home.a a -g test -m创建一个用户名字叫a,主目录在/home/a,如果主目录不存在,就自动创建主目录,同时用户属于test组cat /etc/passwd 查看当前用户的信息 passwdpasswd 设置用户密码早Unix/Linux中,超级用户可以使用passwd命令为普通用户设置或修改用户口令.用户也可以直接使用该命令来修改自己的口令,而无需在命令后面使用用户名 userdeluserdel 删除用户用法:userdel abc 删除abc用户,但不会自动删除用户的主目录userdel -r abc 删除abc用户,同时删除用户的主目录(用户名相同的组也删除了) susu 切换用户用法:su abc 切换到abc用户,键入命令后输入abc用户的密码即可以切换到abc用户直接使用su 用户名,切换用户后并不会进去到该用户的主目录,可以在su命令后加个- su - 用户名 这样切换用户之后直接就在该用户的主目录下注意:在ubuntu下,执行命令前需要加sudo sudo su root在ubuntu下,一些需要root才能操作的命令,可以直接在命令前加sudo执行,这样就免去了要切换到管理员的麻烦 sudo -s 切换到超级管理员的一个简单用法 查看有哪些用户组方法一:cat /etc/group方法二:groupmod + 三次tab键 groupadd groupdelgroupadd 添加组帐号 groupdel 删除组帐号用法:groupadd 组名groupdel 组名执行groupadd和groupdel命令需要超级管理员权限,可以切换到超级管理员sudo -s 或者在命令前加上sudo执行 usermodusermod 修改用户所在组用法:usermod -g 用户组 用户名注意:-g添加的组属于用户的默认组,用户所创建的文件显示的组就是默认组 -G一般与 -a 使用,用于追加组 groupsgroups 查看用户在哪些组用法:groups 用户名 为创建的普通用户添加sudo权限新创建的用户,默认不能sudo,需要进行以下两步操作sudo usermod -a -G adm 用户名sudo usermod -a -G sudo 用户名 usermod -g 和 -G的区别-g 用来制定这个用户默认的用户组-G 一般配合’-a’来完成向其他组添加 chmodchmod 修改文件权限chmod修改文件权限有两种使用格式:字母法与数字法字母法:chmod u/g/o/a +/-/= rwx 文件u user,代表文件的所有者g group,表示与该文件的所有者属于同一组者,即用户组o other,表示其他人a all,表示这三者都是 增加权限 撤销权限= 设定权限r read,表示可读取,对于一个目录,如果没有r权限,那么就意味着不能通过ls查看这个目录的内容w write,表示可写入,对于一个目录,如果没有w权限,那么就意味着不能在目录下创建新的文件.x excute,表示可执行,对于一个目录,如果没有x权限,那么就以为这不能通过cd进入这个目录 用法:chmod u+x test 给用户添加test目录的执行权限chmod g-r test 给同组的用户撤销test目录的可读权限chmod u+x,g-r,u+r test 给用户,同组其他人分别进行权限操作chmod a+x test 给用户,同组其他人都加上test目录的可执行权限 数字法:“rwx”这些权限也可以用数字来代替r 读取权限,数字代号为”4”w 读取权限,数字代号为”2”x 执行权限,数字代号为”1” 不具任何权限,数字代号为”0” 用法与上面相同,就是rwx换成相应的数字可以直接使用chmod 777 test 为test目录修改权限,直接使用数字,三个数字分别按顺序代表ugo,不需要显示声明 如果想递归所有目录加上相同权限,需要加上参数 -Rchmod 777 test/ -R test目录下的所有子文件和目录都是777权限 chownchown 修改文件所有者用法:chown 用户名 文件名 需要超级管理员权限 chgrpchgrp 修改文件所属组用法:chgrp 用户组 文件名 需要超级管理员权限 calcal 查看当前日历cal命令用于查看当月日历,-y显示整年日历 datedate 显示或者设置时间设置时间用法:date [MMDDhhmm[[CC]YY]][.ss] + formatCC为年前两位,YY为年的后两位,MM为月,DD为天,hh为小时,mm为分钟,ss为秒如2016年1月2号3点四分55秒写成date 010203042016.55 显示时间格式(date ‘+%y,%m,%d,%H,%M,%S’)显示年月日date ‘+%Y-%m-%d’ psps 查看进程信息进程是一个具有一定独立功能的程序.它是操作系统动态执行的基本单元.ps命令可以查看进程的详细状况常用选项参数:-a 显示终端上的所有进程,包括其他用户的进程-u 显示进程的详细状态-x 显示没有控制终端的进程-w 显示加宽,以便显示更多的信息-r 只显示正在运行的进程一般常用 ps -aux toptop 动态显示进程用来动态显示运行中的进程.top命令能够在运行后,在指定的时间间隔更新显示信息.可以在使用top命令时加上-d来指定显示信息更新的时间间隔.在top命令执行后,可以按以下按键对显示的结果进行排序M 根据内存使用量来排序P 根据CPU占有率来排序T 根据进程运行时间的长短来排序U 可以根据后面输入的用户名来筛选进程K 可以根据后面输入的PID来杀死进程q 退出h 获得帮助 killkill 终止进程kill命令指定进程号的进程,需要配合ps使用.使用方法:kill [-signal] pid信号值从0到15,其中9为绝对终止,可以处理一般信号无法终止的进程 reboot,shutdown,init 关机重启使用方法:reboot 重新启动操作系统shutdown -r now 重新启动操作系统,shutdown会给其他用户提示shutdown -h now 立刻关机,其中now相当于时间为0的状态shutdown -h 20:25 系统在今天的20:25会关机shutdown -h +10 系统再过十分钟后自动关机init 0 关机init 6 重启 df 检测磁盘空间df命令用于检测文件系统的磁盘空间占用和空余情况,可以显示所有文件系统对节点和磁盘块的使用情况常用选项参数:-a 显示所有文件系统的磁盘使用情况-m 以1024字节为单位显示-t 显示各指定文件系统的磁盘空间使用情况-T 显示文件系统 du 检测目录所占磁盘空间du命令用于统计目录或文件所占磁盘空间的大小,该命令的执行结果与df类似,du更侧重于磁盘的使用状况使用方式 du [选项] 目录或文件名常用选项参数:-a 递归显示指定目录中各文件和子目录中文件占用的数据块-s 显示指定文件或目录占用的数据块-b 以字节为单位显示磁盘占用情况-l 计算所有文件大小,对硬链接文件计算多次 ifconfig 查看或配置网卡信息如果,我们只是敲:ifconfig 它会显示所有网卡的信息.通过超级管理员权限,可以修改网卡的信息如: sudo ifconfig 网卡名 ip地址 可以将指定网卡的ip地址修改为设置的 pingping 测试远程主机连通性用法:ping ip地址/域名]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[markdown学习]]></title>
      <url>%2F2016%2F02%2F13%2Fmarkdown%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[强调 星号与下划线都可以,单是斜体,双是粗体,三个是粗斜体,符号可跨行,符号可加空格(单可以,双就不行了) **一个人来到田纳西** __毫无疑问__ *我做的馅饼 是全天下* _最好吃的_ 一个人来到田纳西毫无疑问我做的馅饼是全天下最好吃的 分隔线 三个或更多-_*，必须单独一行 引用 翻译成html就是blockquote标签，符号后的空格可不要 &gt;引用 引用 内层符号前的空格必须要(也不是必须要,就是必须换行) &gt;引用 &gt;&gt;引用中的引用 引用 引用中的引用 标题:Setext方式 =三个或更多(一个=也能形成大标题,小标题) 大标题 = 小标题 - 大标题=小标题- 标题:Atx方式 =#一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 #一级标题 ##二级标题 ###三级标题 ####四级标题 #####五级标题 ######六级标题 无序列表 =符号之后的空格不能少，-+*效果一样，内容可超长,但不能混合使用，因混合是嵌套列表 - 无序列表 - 无序列表 - 无序列表 - 无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！ 无序列表 无序列表 无序列表 无序列表：我很长。我也很长！那比一比啊？比就比！我有这么长，你有我长吗？我有这么这么长！好吧，你赢了！ 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表 + 无序列表 + 无序列表 + 无序列表 + 无序列表 发现了一个问题,就是在无序列表后面跟着写代码快得缩进两次,不然就被追加到最后一个列表项上去了, 不知道怎么回事 无序列表 无序列表 无序列表 无序列表 符号之后的空格不能少，-+*效果一样，但不能混合使用，因混合是嵌套列表 * 无序列表 * 无序列表 * 无序列表 * 无序列表 无序列表 无序列表 无序列表 无序列表 有序列表 =数字不能省略但可无序，点号之后的空格不能少 1. 有序列表 2. 有序列表 3. 有序列表 4. 有序列表 有序列表 有序列表 有序列表 有序列表 嵌套列表 =-+*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少 - 嵌套列表 + 嵌套列表 + 嵌套列表 - 嵌套列表 * 嵌套列表 - 嵌套列表 只能嵌套两层吗?上面的效果如下,并没有三四层嵌套 嵌套列表 嵌套列表 嵌套列表 嵌套列表 嵌套列表 嵌套列表 文字超链 =Tooltips可省略 [windwest的博客](http://iwantthisname.github.io &quot;windwest的博客&quot;) windwest的博客 图片超链 =多个感叹号，Tooltips可省略，要设置大小只能借助HTML标记 ![GitHub Mark](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png &quot;GitHub Mark&quot;) 索引超链：Reference方式 =索引，1 2可以是任意字符 [windwest的博客][1] ![GitHub Octocat][2] [1]:http://IWantThisName.github.io [2]:http://github.global.ssl.fastly.net/images/modules/logos_page/Octocat.png windwest的博客 自动链接 =尖括号 &lt;http://www.baidu.com&gt; &lt;201800978@qq.com&gt; http://www.baidu.com &#x32;&#48;&#49;&#x38;&#x30;&#48;&#57;&#x37;&#56;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#x6d; 代码:行内代码 =在第一行后指定编程语言，也可以不指定 val s = &quot;hello Markdown&quot; println( s )]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[使用七牛云图床管理博客图片]]></title>
      <url>%2F2016%2F02%2F12%2F%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A%E4%BD%BF%E7%94%A8%2F</url>
      <content type="text"><![CDATA[前言 写文不加图片辅助感觉很难描述操作过程,如果使用github管理博客图片资源的话,又会影响文章加载速度.其他的诸如新浪博客相册,qq空间之类的可以上传图片的地方,在markdown文件中加入链接又比较麻烦,得一个个复制.后经朋友推荐,选择了七牛云图床管理博客图片资源.用起来确实蛮方便的. 创建七牛云帐号首先点击进入七牛云官网,在右上角选择注册. 信息填入完毕,点击下一步,选择个人,然后会要求你验证邮箱. 登录你的邮箱点击验证链接,会跳转到注册成功页面,并要求你进行实名验证 点击立即去实名验证 这里有两个选择,人工审核有点麻烦,我就选择了支付宝验证 输入信息之后会跳转到支付宝授权页面,输入支付宝的帐号和密码点击确定,就完成了认证操作 然后会跳转到七牛云登录页面,输入你的邮箱,和一开始填写注册信息时写的密码,就可以登录到七牛云了 登录之后上方会提示你绑定手机号,绑定一下就行了 上面全部完成之后,七牛云的帐号就算注册完毕了!接下来就可以创建对象存储空间了 创建七牛云对象存储空间点击右边菜单栏的对象存储 然后点击新建存储空间 这里的存储空间名称随便填一个就行,建议和github名一样,这样好记忆 使用命令行工具上传本地图片使用七牛云对象存储空间的内容管理页面上传本地资源,比较简单,就不介绍了.下面说一下windows下如何使用命令行工具上传本地图片 首先,下载七牛云提供的命令行工具,点击进入下载页面 然后往下拉,拉到下面这个地方,点击下载就可 下载完成解压,有以下几个文件,分别是各个系统的命令行工具,我是windows64位的,就选择了amd64,将其他的都删除了,并将文件名改为qshell,方便使用 使用qshell的qupload命令,需要提供一个配置文件,在qshell所在目录下新建一个文件,命名为config.json 配置文件中需要以下几个基本配置,详细的可配置参数请点击详细参数进行了解 { &quot;src_dir&quot; : &quot;&quot;, &quot;bucket&quot; : &quot;&quot;, &quot;access_key&quot; : &quot;&quot;, &quot;secret_key&quot; : &quot;&quot; } src_dir:即是你需要上传的图片所在的根目录,从盘符开始 bucket:你的对象存储空间名 access_key和secret_key是七牛云空间提供的密钥,下面将介绍如何获取 登录七牛云,点击个人面板,选择密钥管理 进入密钥页面,复制一下access_key和secret_key并粘贴到config.json中 如何上传本地图片我在d盘下新建了一个文件夹,名为images,在里面放了一个图片为a.jpg,和一个子文件夹,名为folder,在子文件夹里也放了一个图片为b.jpg 之后设置config.json中的src_dir参数为D:\images, 之后就在qshell文件所在目录按住shift然后右键,选择在此处打开命令行窗口,键入 qshell qupload 1 config.json 命令,就可以将本地资源上传到七牛云空间了.命令中的数字值代表启动几个线程上传图片,1代表1个线程,值1-2000之间可选,值并不是越高越好. 图片外链上传的图片外链为域名加上你上传的文件相对于src_dir参数的相对路径.我的src_dir参数为D:\images,则我两个图片相对于这个参数的相对路径分别为a.jpg和folder/b.jpg 我没有为存储空间绑定自己申请的域名,所以只可以用七牛云提供的测试域名,测试域名可以在你的存储空间页面空间概览中看到 我的测试域名是 oles6cv6e.bkt.clouddn.com 则我这两个图片外链分别为oles6cv6e.bkt.clouddn.com/a.jpg 和 oles6cv6e.bkt.clouddn.com/folder/b.jpg 在markdown文件中,使用如下格式,即可以为你的文章插入图片链接了 ![图片信息](图片外链) ![a.jpg](http://oles6cv6e.bkt.clouddn.com/a.jpg) ![b.jpg](http://oles6cv6e.bkt.clouddn.com/folder/b.jpg)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[git+github page+hexo搭建个人博客]]></title>
      <url>%2F2016%2F02%2F11%2Fgit%2Bgithub%20page%2Bhexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[前言 一直想自己搭建一个博客记录学习中遇到的问题,以便以后查阅.在百度了之后,决定采取这最简单而且免费的方式.经过了几个小时的摸索,终于可以在浏览器上访问到自己的博客,还是有点成就感的,所以自己的第一篇博客就决定来记录一下博客的搭建过程. 博客搭建所需环境 windows7 64位 node-v6.95-x64.msi Git-2.11.1-64-bit.exe 2和3直接百度下载,下载完之后点击安装,一路下一步就行,唯一需要注意的就是node的安装目录需要知道在哪里,之后会用到,最好将目录更改成自己好记忆的. 在都安装完之后需要配置一下node的环境变量,在windows桌面右键计算机图标–&gt;点击属性–&gt;点击高级系统设置–&gt;点击环境变量,在下面的系统变量中找到path变量,追加一下node的安装目录. 安装hexo 在node安装目录下,按住shift后点击右键,选择在此处打开命令行窗口 输入 npm install -g hexo 命令 等待稍长一段时间,hexo就安装成功了 开始搭建博客 接着上一步,输入 mkdir blog &amp;&amp; cd blog 命令,创建blog文件夹并进入,这个名字可以是任意的,这个文件夹所在目录就是今后的博客目录 输入 hexo init 命令,初始化hexo博客框架的一些文件 输入 npm install 命令,安装hexo博客框架所需的依赖 以上博客已经搭建成功了,不过只是本地的,此时输入 hexo g 命令即可生成静态页面 执行hexo s 命令,然后在浏览器键入 http://localhost:4000 即可看到博客页面 将本地博客部署到github上 首先得在github上创建一个帐号,点击进入github 点击右上角+号选择new repositry创建仓库,仓库名固定格式为github名.github.io,我的github名是iwantthisname,所以在这里我就输入了iwantthisname.github.io 创建成功之后点击你刚刚创建好的仓库,在右上点击setting.然后找到choose theme,选择一个主题确定(这里主题随便选择一个就行,后面都可以换),这样你的github page就创建成功了,可以试试在浏览器上输入你的github名.github.io看看能不能访问到 再回到仓库主页code那一标签页,点击clone or download后会有一个下拉框,复制框里面的仓库地址 进入node的安装目录,点击刚才创建好的blog文件夹(就是上面说明的博客目录),打开_config.yml文件,在文件任意位置加入以下配置 deploy: type: git repository: (直接粘贴你刚才复制的仓库地址) branch: master 回到你的cmd窗口,执行npm install hexo-deployer-git –save 命令,这命令是用来解决发布项目问题的 执行hexo g 命令生成静态页面 执行hexo d 命令将静态页面推送到github上 在浏览器输入 你的github名.github.io,应该就可以看到你的博客页面了 编写发布博客 首先介绍一下博客目录下一些重要的目录 public:和远程仓库的内容同步 source:这个文件夹下的_post的文件可以用来生成静态资源并发布到远程仓库上 themes:博客的主题文件存放目录 进入source目录下的_post文件夹,这个文件夹下放的一般是markdown文件,所以得先下载markdown编辑器.百度一下即可下载,安装也是一路下一步就行,没什么注意的地方. 编辑器下载完成,即可在这个文件夹下创建一个markdown文件,markdown文件编写语法也比较简单,可以百度个博客稍微学习一下,在文件中编写自己的博客内容 进入命令行中执行 hexo g 命令生成静态资源,在执行hexo d命令进行发布 在浏览器中键入 你的github名.github.io 即可以看到你刚发布的博客啦 使用自己的域名绑定github page如果你觉得github名.github.io这个地址不好记,想用自己申请的域名访问自己的博客,就可以按照下面的步骤,将自己的域名绑定到github page上啦 域名添加github page解析 首先申请个域名,我是在阿里云上申请的,点击进入阿里云 申请好之后,点击控制台,在左边菜单栏进入域名管理 在你申请的域名那一栏 点击解析,进入解析设置页面 点击添加解析,这里需要添加三个 记录类型 主机记录 记录值 TTL A @ 192.30.252.153 10分钟(600秒) A @ 192.30.252.154 10分钟(600秒) CNAME www github名.github.io 10分钟(600秒) github page添加域名解析 回到你的github主页,进入你的github page仓库,进入Setting页面,在Customer domain栏里填入你的域名,点击save保存 静待片刻,在浏览器输入你的域名,即可看到你的博客页面了]]></content>
    </entry>

    
  
  
</search>
